<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"><channel><title>GitHub Changelog</title><atom:link href="https://github.blog/changelog/feed/" rel="self" type="application/rss+xml"></atom:link><link>https://github.blog/changelog/</link><description>Updates, ideas, and inspiration from GitHub to help developers build and design software.</description><lastBuildDate>Thu, 29 Aug 2024 21:55:39 +0000</lastBuildDate><language>en-US</language><sy:updatePeriod>hourly</sy:updatePeriod><sy:updateFrequency>1</sy:updateFrequency><generator>https://wordpress.org/?v=6.6.1</generator><image><url>https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=32%2C32</url><title>GitHub Changelog</title><link>https://github.blog/changelog/</link><width>32</width><height>32</height></image><site xmlns="com-wordpress:feed-additions:1">153214340</site><item><title>リポジトリ権限をカスタム組織ロールに追加する</title><link>https://github.blog/changelog/2024-08-29-add-repository-permissions-to-custom-organization-roles</link><dc:creator>Allison</dc:creator><pubDate>Thu, 29 Aug 2024 21:55:39 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-29-add-repository-permissions-to-custom-organization-roles</guid><description>&lt;p&gt;Add repository permissions to custom organization roles&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-29-add-repository-permissions-to-custom-organization-roles&quot;&gt;Add repository permissions to custom organization roles&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;カスタム組織ロールにリポジトリ権限を追加して、組織内のすべてのリポジトリに特定のレベルのアクセス権を付与できるようになりました。&lt;br /&gt;
これは、GitHub の事前定義された組織ロールにおける&lt;a href=&quot;https://github.blog/changelog/2024-07-10-pre-defined-organization-roles-that-grant-access-to-all-repositories/&quot;&gt;組織全体の権限付与&lt;/a&gt;のリリースに基づいています。 &lt;/p&gt;
&lt;p&gt;&lt;img decoding=&quot;async&quot; width=&quot;700&quot; alt=&quot;新しいリポジトリ権限を使用してカスタム組織ロールを作成します。このロールは書き込み基本ロールに基づいており、課題の削除、単独マージの要求、リポジトリのプロパティの更新の 3 つの権限が追加されます。&quot; src=&quot;https://github.com/user-attachments/assets/d0fa1490-df1c-46e3-a88d-368216306f40&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;using-repository-permissions-in-organization-roles&quot;&gt;組織ロールでのリポジトリ権限の使用&lt;a href=&quot;#using-repository-permissions-in-organization-roles&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;Using repository permissions in organization roles&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;組織ロールに組織権限 (つまり、 &lt;code&gt;read_org_audit_log&lt;/code&gt; ) を含める必要はありません。&lt;br /&gt;
リポジトリのロールと権限 (つまり&lt;code&gt;close_issue&lt;/code&gt; )。これにより、事前定義されたバージョンの独自のバージョンを作成できます。&lt;br /&gt;
 &lt;code&gt;Write&lt;/code&gt;や&lt;code&gt;Triage&lt;/code&gt;などの組織の基本ロール。これらのロールを組織内の全員に割り当てて、&lt;br /&gt;
要件に合ったアクセス標準を設定します。&lt;/p&gt;
&lt;p&gt;一般的な使用例は、オンコール ローテーション用に昇格されたロールを作成することです。たとえば、 &lt;code&gt;Write&lt;/code&gt;に基づくロールは、&lt;br /&gt;
 「マージ キューをジャンプする」および「単独マージをリクエストする」リポジトリ権限が追加され、オンコール チームが取得できるようになりました。&lt;br /&gt;
それはすぐに修正されます。 API を使用すると、現在のオンコールへのこのロールの割り当てを自動化し、それらに権限を付与できます。&lt;br /&gt;
これらの昇格されたアクセス許可は、非常事態またはシフトベースの特権として付与されます。&lt;/p&gt;
&lt;h2 id=&quot;managing-repository-access&quot;&gt;リポジトリへのアクセスの管理&lt;a href=&quot;#managing-repository-access&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;Managing repository access&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;組織ロール作成用の UI と&lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/rest/orgs/organization-roles?apiVersion=2022-11-28#create-a-custom-organization-role&quot;&gt;REST API の&lt;/a&gt;両方が、リポジトリ権限をサポートするように更新されました。&lt;br /&gt;
さらに、リポジトリ アクセス管理ページを更新して、&lt;br /&gt;
リポジトリ所有者からユーザーまたはチームへの付与と、組織所有者による組織全体への付与の比較。これは役に立ちます&lt;br /&gt;
ユーザーが特定のリポジトリにアクセスする方法を説明します。 &lt;/p&gt;
&lt;p&gt;&lt;img decoding=&quot;async&quot; width=&quot;700&quot; alt=&quot;新しいリポジトリ コラボレータ ビューには、組織ベースのアクセスが表示されます。&quot; src=&quot;https://github.com/user-attachments/assets/260aa2a5-c50e-4b57-9ebd-f89f0b131221&quot;&gt;&lt;/p&gt;
&lt;p&gt;詳細については、 &lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/about-custom-organization-roles&quot;&gt;GitHub のドキュメント&lt;/a&gt;と、ロールの作成と割り当てを自動化するための&lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/rest/orgs/organization-roles?apiVersion=2022-11-28#create-a-custom-organization-role&quot;&gt;REST API メソッド&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.blog/changelog/2024-08-29-add-repository-permissions-to-custom-organization-roles&quot;&gt;「カスタム組織ロールにリポジトリ権限を追加する」という&lt;/a&gt;記事は、最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79615</post-id></item><item><title>Unkey は GitHub シークレット スキャン パートナーになりました</title><link>https://github.blog/changelog/2024-08-29-unkey-is-now-a-github-secret-scanning-partner</link><dc:creator>Allison</dc:creator><pubDate>Thu, 29 Aug 2024 21:06:06 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-29-unkey-is-now-a-github-secret-scanning-partner</guid><description>&lt;p&gt;Unkey is now a GitHub secret scanning partner&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-29-unkey-is-now-a-github-secret-scanning-partner&quot;&gt;Unkey is now a GitHub secret scanning partner&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.unkey.com/&quot;&gt;Unkey&lt;/a&gt;ユーザーの場合、GitHub シークレット スキャンで Unkey トークンがスキャンされ、パブリック リポジトリのセキュリティが確保されるようになりました。 Unkey のルート API キーを使用すると、ユーザーは API、API キー、グローバル レート制限、アクセス制御などの Unkey リソースを作成および管理できます。 GitHub は、公開リポジトリで見つかった公開されたトークンを Unkey に転送し、Unkey は侵害されたトークンを取り消し、影響を受けるユーザーに通知します。 &lt;a href=&quot;https://unkey.dev/docs/security/github-scanning&quot;&gt;Unkey トークンの詳細については、こちらをご覧ください&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; GitHub シークレット スキャンは、トークンや秘密キーなどの既知のタイプのシークレットをリポジトリで検索することでユーザーを保護します。これらの秘密を特定してフラグを立てることで、スキャンはデータ漏洩や不正行為の防止に役立ちます。&lt;/p&gt;
&lt;p&gt; GitHub Advanced Security の顧客は、プライベート リポジトリ内の Unkey トークンをスキャンしてブロックすることもできます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/github/administering-a-repository/about-secret-scanning&quot;&gt;シークレットスキャンについて詳しく見る&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/developers/overview/secret-scanning/&quot;&gt;シークレットスキャンに関して GitHub と提携する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.blog/changelog/2024-08-29-unkey-is-now-a-github-secret-scanning-partner&quot;&gt;Unkey は GitHub シークレット スキャン パートナーになりました&lt;/a&gt;最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79614</post-id></item><item><title>シークレットスキャンによるバイパスのためのきめ細かな権限</title><link>https://github.blog/changelog/2024-08-29-secret-scanning-fine-grained-permissions-for-bypasses</link><dc:creator>Allison</dc:creator><pubDate>Thu, 29 Aug 2024 20:46:47 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-29-secret-scanning-fine-grained-permissions-for-bypasses</guid><description>&lt;p&gt;Secret scanning fine-grained permissions for bypasses&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-29-secret-scanning-fine-grained-permissions-for-bypasses&quot;&gt;Secret scanning fine-grained permissions for bypasses&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;組織内のプッシュ保護バイパス要求を確認および管理するためのきめ細かい権限を付与できるようになりました。&lt;/p&gt;
&lt;p&gt;この権限を持つユーザーは誰でも、バイパス要求のリストを承認および管理できます。 &lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/delegated-bypass-for-push-protection/enabling-delegated-bypass-for-push-protection#configuring-delegated-bypass-for-an-organization&quot;&gt;コードのセキュリティと分析の設定&lt;/a&gt;の「バイパス リスト」にロールまたはチームを追加することで、これらの権限を付与することもできます。&lt;/p&gt;
&lt;p&gt;来月、GitHub はこの変更に伴い、カスタム ロールのサポートをバイパス リストから削除する予定です。混乱を避けるために、以前にバイパスレビュー担当者として追加された既存のカスタムロールには、バイパスリクエストをレビューおよび管理するためのきめ細かい権限が付与されます。&lt;/p&gt;
&lt;p&gt;シークレット スキャン プッシュ保護の&lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/delegated-bypass-for-push-protection/about-delegated-bypass-for-push-protection&quot;&gt;委任バイパス&lt;/a&gt;により、組織やリポジトリは、シークレットを含むコミットをプッシュできるユーザーを制御できます。開発者は、ブロックされたシークレットをプッシュするために、承認されたユーザーに承認を要求できます。&lt;/p&gt;
&lt;h4 id=&quot;learn-more&quot;&gt;もっと詳しく知る&lt;a href=&quot;#learn-more&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;Learn more&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/about-secret-scanning&quot;&gt;シークレット スキャンを使用してリポジトリを保護する&lt;/a&gt;方法について詳しくは、こちらをご覧ください。 &lt;a href=&quot;https://github.com/orgs/community/discussions/categories/code-security&quot;&gt;GitHub コミュニティのディスカッション&lt;/a&gt;に参加するか、 &lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSeQ8KzKQDvh7AD2vuTlqsPWkSo-IHh5XJUXdE6YmmLe8F98Kg/viewform?usp=sf_link&quot;&gt;60 分間のフィードバック セッション&lt;/a&gt;にサインアップして、ご意見をお聞かせください。&lt;/p&gt;
&lt;p&gt;投稿「 &lt;a href=&quot;https://github.blog/changelog/2024-08-29-secret-scanning-fine-grained-permissions-for-bypasses&quot;&gt;シークレット スキャンによるバイパスのためのきめ細かなアクセス許可」は、&lt;/a&gt;最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79613</post-id></item><item><title>GitHub スポンサーの新機能</title><link>https://github.blog/changelog/2024-08-29-whats-new-in-github-sponsors</link><dc:creator>Allison</dc:creator><pubDate>Thu, 29 Aug 2024 19:18:00 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-29-whats-new-in-github-sponsors</guid><description>&lt;p&gt;What&apos;s New in GitHub Sponsors&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-29-whats-new-in-github-sponsors&quot;&gt;What&amp;#8217;s New in GitHub Sponsors&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;&lt;strong&gt;組織のスポンサー活動をすべて 1 か所で表示します。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;組織は、GitHub スポンサー関連のアクティビティを 1 か所で簡単に確認できるようになりました。スポンサー ダッシュボードから、現在および過去のスポンサーシップを表示したり、一括スポンサーシップを作成したり、依存関係を表示したりできます。特定のプロジェクトを検索したり、すべての依存関係をエクスポートしたりして、スポンサーとなるメンテナーを簡単に見つけることができます。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/sponsors/getting-started-with-github-sponsors/navigating-your-sponsors-dashboard&quot;&gt;スポンサー ダッシュボード&lt;/a&gt;の詳細については、こちらをご覧ください。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ソーシャルメディアでスポンサーシップを共有する&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;メンテナンス者とスポンサーは、ボタンをクリックするだけでソーシャル メディア上でスポンサーシップを共有し、祝うことができます。メンテナはスポンサーとつながり、目標を共有できます。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/editing-your-profile-details-for-github-sponsors#sharing-your-profile&quot;&gt;ソーシャルでの共有&lt;/a&gt;について詳しくは、こちらをご覧ください。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.blog/changelog/2024-08-29-whats-new-in-github-sponsors&quot;&gt;GitHub スポンサーの新機能に関する&lt;/a&gt;投稿 最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79612</post-id></item><item><title>GitHub.com の Copilot Chat で GitHub エンティティ全体を検索できるようになりました</title><link>https://github.blog/changelog/2024-08-29-copilot-chat-in-github-com-now-can-search-across-github-entities</link><dc:creator>Allison</dc:creator><pubDate>Thu, 29 Aug 2024 16:35:18 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-29-copilot-chat-in-github-com-now-can-search-across-github-entities</guid><description>&lt;p&gt;Copilot Chat in GitHub.com now can search across GitHub entities&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-29-copilot-chat-in-github-com-now-can-search-across-github-entities&quot;&gt;Copilot Chat in GitHub.com now can search across GitHub entities&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;&lt;img decoding=&quot;async&quot; src=&quot;https://github.com/user-attachments/assets/3bc3e105-e218-4b10-9a8b-07b96ae5b5af&quot; alt=&quot;画像&quot; /&gt;&lt;/p&gt;
&lt;p&gt;この変更により、GitHub.com の Copilot Chat 内で自然言語を使用して、GitHub 全体を検索してコミット、問題、プル リクエスト、リポジトリ、トピックを見つけることができるようになりました。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自分で試してみてください:&lt;/strong&gt;&lt;br /&gt;
 – &lt;code&gt;What are the most recent issues assigned to me?&lt;/code&gt;&lt;br /&gt;
 – &lt;code&gt;What repos are related to [insert topic]?&lt;/code&gt;&lt;br /&gt;
 – &lt;code&gt;What is the most recent PR from @user?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;また、Copilot の会話履歴の保存方法をより効率的にするために、内部的にいくつかの変更を加えました。これは、Copilot が会話の履歴をより多く記憶できるようになり、より多くの情報に基づいた信頼性の高い応答が得られることを意味します。 &lt;img src=&quot;https://s.w.org/images/core/emoji/15.0.3/72x72/2728.png&quot; alt=&quot;✨&quot; class=&quot;wp-smiley&quot; style=&quot;height: 1em; max-height: 1em;&quot; /&gt; 。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com/orgs/community/discussions/categories/announcements&quot;&gt;GitHub コミュニティ&lt;/a&gt;内のディスカッションに参加してください。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.blog/changelog/2024-08-29-copilot-chat-in-github-com-now-can-search-across-github-entities&quot;&gt;GitHub.com の Copilot Chat で GitHub エンティティ全体を検索できるようになった&lt;/a&gt;という投稿は、最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79608</post-id></item><item><title>GitHub Enterprise Server 3.14 が一般提供されました</title><link>https://github.blog/changelog/2024-08-29-github-enterprise-server-3-14-is-generally-available</link><dc:creator>Allison</dc:creator><pubDate>Thu, 29 Aug 2024 16:16:20 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-29-github-enterprise-server-3-14-is-generally-available</guid><description>&lt;p&gt;GitHub Enterprise Server 3.14 is generally available&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-29-github-enterprise-server-3-14-is-generally-available&quot;&gt;GitHub Enterprise Server 3.14 is generally available&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;h2 id=&quot;github-enterprise-server-3-14-is-generally-available&quot;&gt;GitHub Enterprise Server 3.14 が一般提供されました&lt;a href=&quot;#github-enterprise-server-3-14-is-generally-available&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;GitHub Enterprise Server 3.14 is generally available&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt; GitHub Enterprise Server 3.14 は、お客様に強化された導入要件とセキュリティ制御を提供します。 3.14 リリースのハイライトをいくつか紹介します。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;strong&gt;GHES 用 SCIM は、&lt;/strong&gt;広くリクエストされているエンタープライズ ID 管理機能であり、現在パブリック ベータ版で利用可能です。 SCIM は「System for Cross-domain Identity Management」の略で、SaaS アプリケーションにおけるユーザー ライフサイクル管理の主要な標準です。エンタープライズ管理者は、GitHub Enterprise Server インスタンス用に SCIM を構成できます。これにより、SCIM API を介した新しいユーザー アカウントとグループの自動プロビジョニングがサポートされます。 SAML と SCIM サポートを 1 か所で組み合わせた Entra ID や Okta など、いくつかの舗装されたパス アプリケーションをサポートしています。さらに、独自の SAML ID プロバイダーと SCIM 実装を GitHub Enterprise Server に導入して、独自の ID とユーザーのライフサイクル管理のニーズを満たすことができます。開始するには、GitHub Enterprise Server の&lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/admin/managing-iam/using-saml-for-enterprise-iam/configuring-user-provisioning-with-scim-for-your-enterprise&quot;&gt;SCIM&lt;/a&gt;ドキュメントにアクセスしてください。パブリック ベータ版では、現在のセットアップに SCIM を追加する前に、非実稼働 GHES 環境で ID システムの SCIM サポートをテストすることをお勧めします。 SCIM サポートは既存の SAML 実装に追加できますが、IdP で SCIM を介した自動プロビジョニングをサポートする新しいアプリケーションを使用する必要があります。既存のプライベート ベータ版の顧客も、更新された IdP アプリケーションを使用して実装を再構成する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; SAML 設定は、エンタープライズ設定ページに読み取り専用構成として表示されるようになりました。エンタープライズ管理者は、エンタープライズ インスタンスに対して SCIM サポートが構成されているのと同じ場所でこれらの設定を表示できます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;カスタムの組織ロールを導入し、組織の管理業務の一部を信頼できるチームやユーザーに委任できるようにします。組織管理者は、これらのカスタム ロールを管理するための UI と&lt;strong&gt;API の&lt;/strong&gt;両方を備えています。 &lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/organizations/managing-peoples-access-to-your-organization-with-roles/about-custom-organization-roles&quot;&gt;「カスタム組織の役割」を&lt;/a&gt;参照してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;リポジトリ ルールのコード スキャン オプションが、&lt;/strong&gt; GHES のパブリック ベータ版で利用できるようになりました。ステータス チェックに依存する代わりに、専用のコード スキャン ルールを作成してプル リクエストのマージをブロックできるようになりました。これにより、コード ベースに新たな脆弱性が導入されるのをこれまでより簡単に防ぐことができます。 &lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/code-security/code-scanning/managing-your-code-scanning-configuration/set-code-scanning-merge-protection#creating-a-merge-protection-ruleset-for-all-repositories-in-an-organization&quot;&gt;「コード スキャン マージ保護の設定」を&lt;/a&gt;参照してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; dependabot のグループ化されたセキュリティ更新プログラムが一般提供されるようになりました。この機能により&lt;strong&gt;、Dependabot プル リクエストが自動的にグループ化され&lt;/strong&gt;、いくつかの追加オプションを指定してグループ化を微調整できるようになります。リポジトリまたは組織レベルで、Dependabot の&lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/code-security/dependabot/dependabot-security-updates/about-dependabot-security-updates#about-grouped-security-updates&quot;&gt;グループ化されたセキュリティ更新を有効にすること&lt;/a&gt;ができます。 dependabot のグループ化をより詳細に制御したい場合は、リポジトリで&lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#groups&quot;&gt;dependabot.yml ファイルを構成する&lt;/a&gt;こともできます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 2 世代 VM のサポートにより、オペレーターは GHES アプライアンスを垂直方向に拡張できます。 3.14 以降の新規インストールは、ブート ファームウェア、BIOS、および&lt;strong&gt;UEFI の&lt;/strong&gt;両方をサポートすることにより、新しい世代のハードウェアで起動します。 &lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/admin/monitoring-managing-and-updating-your-instance/updating-the-virtual-machine-and-physical-resources/using-generation-2-virtual-machines&quot;&gt;「第 2 世代 VM」&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;複数のレプリカ ノードを持つインスタンスで、1 回の構成実行ですべてのノードのレプリケーションを開始または停止するには、オペレーターは&lt;strong&gt;ghe-repl-start-all&lt;/strong&gt;および&lt;strong&gt;ghe-repl-stop-all&lt;/strong&gt;コマンドを使用できます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/en/enterprise-server@3.14/admin/release-notes&quot;&gt;GitHub Enterprise Server 3.14 の詳細については、リリース ノートを&lt;/a&gt;参照するか、&lt;a href=&quot;https://enterprise.github.com/releases/3.14.0/download&quot;&gt;今すぐダウンロードしてください&lt;/a&gt;。 GitHub Enterprise Server Appliance をバージョン 3.14 にアップグレードする際に問題がある場合、または新機能の使用に問題がある場合は、&lt;a href=&quot;https://support.github.com/features/enterprise-administrators-server&quot;&gt;サポート チームにお問い合わせ&lt;/a&gt;ください。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/orgs/community/discussions/136986&quot;&gt;コミュニティのディスカッションに&lt;/a&gt;参加して、フィードバックを共有したり、質問したりできます。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.blog/changelog/2024-08-29-github-enterprise-server-3-14-is-generally-available&quot;&gt;GitHub Enterprise Server 3.14 の一般提供に関する&lt;/a&gt;記事は、 &lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に最初に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79607</post-id></item><item><title>CodeQL コード スキャンは、ビルドを必要とせずに Java および C# コードベースを分析できます (GA)</title><link>https://github.blog/changelog/2024-08-28-codeql-code-scanning-can-analyze-java-and-c-codebases-without-needing-a-build-ga</link><dc:creator>Allison</dc:creator><pubDate>Wed, 28 Aug 2024 14:53:16 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-28-codeql-code-scanning-can-analyze-java-and-c-codebases-without-needing-a-build-ga</guid><description>&lt;p&gt;CodeQL code scanning can analyze Java and C# codebases without needing a build (GA)&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-28-codeql-code-scanning-can-analyze-java-and-c-codebases-without-needing-a-build-ga&quot;&gt;CodeQL code scanning can analyze Java and C# codebases without needing a build (GA)&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;CodeQL コード スキャンでは、ビルドを観察しなくても Java および C# コードを分析できるようになりました。これにより、特に&lt;a href=&quot;https://docs.github.com/en/code-security/securing-your-organization/&quot;&gt;GHAS セキュリティ構成&lt;/a&gt;を使用してリポジトリを有効にして管理する場合、多数のリポジトリに対してセキュリティ分析を展開することが容易になります。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning-with-codeql&quot;&gt;CodeQL は&lt;/a&gt;、GitHub コード スキャンを強化する分析エンジンです。ソース コードを分析する場合、分析エンジンがコードベースのあらゆる側面について詳細な知識を持っていることが重要です。現在、分析エンジンは Java および C# コードのビルド プロセスの観察に依存しなくなり、その結果、セットアップの成功率と CodeQL コード スキャン (Java および C#) の採用率が向上しました。&lt;/p&gt;
&lt;p&gt;この機能のテスト中に、分析結果が以前の方法論と同じくらい正確であることを検証しました。この機能は、今年初めにパブリック ベータ版 ( &lt;a href=&quot;https://github.blog/changelog/2024-03-26-codeql-can-scan-java-projects-without-a-build/&quot;&gt;Java&lt;/a&gt; 、 &lt;a href=&quot;https://github.blog/changelog/2024-06-20-codeql-can-scan-c-projects-without-requiring-working-builds-public-beta/&quot;&gt;C#&lt;/a&gt; ) として提供されており、そのとき、これらの言語の CodeQL コード スキャンの新規ユーザー向けの新しいデフォルト分析モードになりました。以前は数週間かかっていた一部のタスクが数分で完了できるようになり、時間を大幅に節約できるようになったお客様もいます。&lt;/p&gt;
&lt;p&gt; Java と C# の両方に対する CodeQL の新しいゼロ構成分析メカニズムは、GitHub.com で利用できます。これらのリポジトリに対して CodeQL コード スキャンを設定している場合は、デフォルトでこの分析メカニズムの恩恵を受けることができます。この機能のそれぞれのパブリック ベータ リリース前に Java または C# の CodeQL コード スキャンを設定した場合、分析は変更されません (ただし、現在の設定を無効にし、 &lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/code-security/code-scanning/enabling-code-scanning/configuring-default-setup-for-code-scanning&quot;&gt;デフォルトの設定&lt;/a&gt;を使用してコード スキャンを再度有効にすることで移行できます)。この新機能は、Java の場合はバージョン 3.14、C# の場合は 3.15 以降、GitHub Enterprise Server (GHES) の顧客にもリリースされます。&lt;/p&gt;
&lt;p&gt;コード スキャンの&lt;a href=&quot;https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/configuring-advanced-setup-for-code-scanning&quot;&gt;詳細設定&lt;/a&gt;を使用するリポジトリは、アクション ワークフロー ファイルで指定されている分析メカニズムを引き続き使用します。新しい分析構成のテンプレートは、「build-mode: none」を指定することで新しい分析メカニズムを使用するようになりました。 &lt;a href=&quot;https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages\#codeql-build-modes&quot;&gt;古い分析メカニズム&lt;/a&gt;も引き続き利用できます。 CodeQL CLI のユーザーは、 &lt;a href=&quot;https://docs.github.com/en/code-security/codeql-cli/codeql-cli-manual/database-create\#--build-modemode&quot;&gt;ここで&lt;/a&gt;詳細なドキュメントを見つけることができます。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning&quot;&gt;GitHub コード スキャン&lt;/a&gt;の詳細については、こちらをご覧ください。 Java および C# のこれらの新しい分析メカニズムについてフィードバックがある場合は、&lt;a href=&quot;https://github.com/orgs/community/discussions/113548&quot;&gt;ここの&lt;/a&gt;ディスカッションに参加してください。&lt;/p&gt;
&lt;p&gt; Post &lt;a href=&quot;https://github.blog/changelog/2024-08-28-codeql-code-scanning-can-analyze-java-and-c-codebases-without-needing-a-build-ga&quot;&gt;CodeQL コード スキャンは、ビルドを必要とせずに Java および C# コードベースを分析できます (GA)&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt; .&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79602</post-id></item><item><title>GitHub Copilot のカスタム モデルが限定公開ベータ版になりました</title><link>https://github.blog/changelog/2024-08-27-custom-models-for-github-copilot-are-now-in-limited-public-beta</link><dc:creator>Allison</dc:creator><pubDate>Tue, 27 Aug 2024 21:27:06 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-27-custom-models-for-github-copilot-are-now-in-limited-public-beta</guid><description>&lt;p&gt;Custom models for GitHub Copilot are now in Limited Public Beta&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-27-custom-models-for-github-copilot-are-now-in-limited-public-beta&quot;&gt;Custom models for GitHub Copilot are now in Limited Public Beta&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;GitHub Copilot のカスタム モデルが、Copilot Enterprise の限定パブリック ベータで利用できるようになりました。この新機能により、Copilot を微調整して、組織独自のコーディング手法をよりよく理解し、それに合わせて、プロジェクト全体にわたるコード提案の関連性と正確性を向上させることができます。&lt;/p&gt;
&lt;h3 id=&quot;what-are-custom-models&quot;&gt;カスタムモデルとは何ですか? &lt;a href=&quot;#what-are-custom-models&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;What are custom models?&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;カスタム モデルは、組織のコードベースを使用して微調整された大規模言語モデル (LLM) です。独自のライブラリ、特殊な言語、内部コーディング パターンに基づいてモデルをトレーニングすることにより、Copilot は、よりコンテキストを認識し、組織のニーズに合わせたコード提案を提供します。&lt;/p&gt;
&lt;p&gt;このベータ版では、GitHub リポジトリを使用してカスタム モデルを作成できます。オプションで、開発者の Copilot プロンプトと応答からのコード スニペットとテレメトリの収集を有効にして、モデルをさらに微調整することもできます。このプロセスにより、Copilot の提案がコーディングの実践と密接に一致し、提案がより関連性があり正確なものになります。その結果、開発チームはコードレビュー、デバッグ、手動コード調整に費やす時間が短縮され、最終的にチームの生産性が向上し、より一貫したコード品質が保証されます。 &lt;/p&gt;
&lt;p&gt;&lt;img decoding=&quot;async&quot; src=&quot;https://github.blog/wp-content/uploads/2024/08/361007775-b7d83949-f827-4f76-84bd-c30a83273044.png&quot; alt=&quot;カスタムモデルトレーニング構成&quot; /&gt;&lt;/p&gt;
&lt;p&gt;重要なのは、あなたのデータは完全にあなたのもののままです。他の顧客のモデルをトレーニングするために使用されることはなく、カスタム モデルは非公開に保たれるため、完全な制御、セキュリティ、プライバシーが確保されます。&lt;/p&gt;
&lt;h3 id=&quot;when-to-use-custom-models&quot;&gt;カスタム モデルを使用する場合&lt;a href=&quot;#when-to-use-custom-models&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;When to Use Custom Models&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;カスタム モデルを使用すると、Copilot の提案を特定のニーズにさらに適合させることができ、開発者の間で Copilot が提案したコードの受け入れ率を高めることができます。次のシナリオではカスタム モデルの使用を検討してください。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ライブラリと API の使用を強化する:&lt;/strong&gt;組織がパブリック データセットで十分に表現されていないカスタム ライブラリや API に大きく依存している場合、カスタム モデルはこれらを優先して提案できるため、開発者が内部標準に準拠しやすくなります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特殊な言語のサポートを改善する:&lt;/strong&gt;チームがあまり一般的ではない言語や独自の言語を使用している場合、カスタム モデルを使用することで Copilot をより効率的にすることができます。微調整により、Copilot はこれらの言語をよりよく理解できるようになり、摩擦が軽減され、生産性が向上します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;進化するコードベースに適応する:&lt;/strong&gt;コードベースが変化しても、カスタム モデルをいつ、どのくらいの頻度で再トレーニングするかを完全に制御できます。定期的に再トレーニングすることで、Copilot が最新のコーディング パターンに確実に対応できるようになり、関連性のある正確な提案を提供し続けることができます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;how-to-get-started&quot;&gt;始め方&lt;a href=&quot;#how-to-get-started&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;How to Get Started&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ベータ版にサインアップ:&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/github-copilot/fine_tuning_waitlist_signup/join&quot;&gt;ここでサインアップして&lt;/a&gt;限定パブリック ベータに参加し、組織が Copilot Enterprise プランに参加していることを確認してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;リポジトリを準備します。&lt;/strong&gt;&lt;br /&gt;
組織のコーディング標準を最もよく反映するリポジトリを選択してください。微調整を最大限に活用するには、独自のライブラリ、特殊な言語、または主要な内部フレームワークを備えたものを含めます。企業に複数の GitHub 組織がある場合、このベータ期間中のトレーニングに使用できるのは 1 つの組織とそのリポジトリのみであることに注意してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;テレメトリ収集を有効にする:&lt;/strong&gt;&lt;br /&gt;
モデルをさらにカスタマイズするには、開発者のプロンプトとコパイロットの提案に関連するコード スニペットとテレメトリのコレクションを有効にすることを検討してください。このデータは安全に収集され、さらなる微調整に使用され、チームにとっての Copilot の出力の精度と関連性が向上します。データはカスタム モデルを強化するためにのみ使用され、他のユーザーと共有されることはありません。当社のデータ処理慣行の詳細については、&lt;a href=&quot;https://resources.github.com/copilot-trust-center/&quot;&gt;トラスト &amp; セキュリティ センター&lt;/a&gt;にアクセスするか、GitHub の&lt;a href=&quot;https://github.com/customer-terms/github-data-protection-agreement&quot;&gt;データ保護契約&lt;/a&gt;を確認してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;トレーニングと使用法:&lt;/strong&gt;&lt;br /&gt;
セットアップ後、カスタム モデルは選択したリポジトリを使用してトレーニングされます。準備が完了すると、開発者の IDE はカスタム モデルの使用を自動的に開始し、すべてのインライン コード補完に通知します。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;モニタリングと品質評価:&lt;/strong&gt;&lt;br /&gt;
カスタム モデルを定期的に再トレーニングして、新しいコードと進化する実践に合わせて調整します。 &lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/rest/copilot/copilot-usage?apiVersion=2022-11-28&quot;&gt;Copilot 使用状況メトリック API を&lt;/a&gt;使用して、提案受け入れ率などのメトリックを追跡し、どれだけ改善されているかを確認します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;additional-resources&quot;&gt;追加リソース&lt;a href=&quot;#additional-resources&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;Additional Resources&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/github-copilot/fine_tuning_waitlist_signup/join&quot;&gt;カスタム モデルの待機リストに参加してください&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;カスタム モデルの詳細については、 &lt;a href=&quot;https://docs.github.com/enterprise-cloud@latest/copilot/managing-copilot/managing-github-copilot-in-your-organization/customizing-copilot-for-your-organization/creating-a-custom-model-for-github-copilot&quot;&gt;ドキュメント&lt;/a&gt;を参照してください。&lt;/li&gt;
&lt;li&gt;ご質問またはご提案はありますか?&lt;a href=&quot;https://github.com/orgs/community/discussions/136434&quot;&gt;コミュニティディスカッション&lt;/a&gt;の会話に参加してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;a href=&quot;https://github.blog/changelog/2024-08-27-custom-models-for-github-copilot-are-now-in-limited-public-beta&quot;&gt;GitHub Copilot のカスタム モデルは限定公開ベータ版になりました&lt;/a&gt;最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79595</post-id></item><item><title>シークレット スキャンにより、プッシュ保護バイパスのブランチ パスとファイル パスが表示されます。</title><link>https://github.blog/changelog/2024-08-26-secret-scanning-displays-branch-and-file-paths-for-push-protection-bypasses</link><dc:creator>Allison</dc:creator><pubDate>Mon, 26 Aug 2024 20:42:03 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-26-secret-scanning-displays-branch-and-file-paths-for-push-protection-bypasses</guid><description>&lt;p&gt;Secret scanning displays branch and file paths for push protection bypasses&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-26-secret-scanning-displays-branch-and-file-paths-for-push-protection-bypasses&quot;&gt;Secret scanning displays branch and file paths for push protection bypasses&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;&lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/delegated-bypass-for-push-protection/about-delegated-bypass-for-push-protection&quot;&gt;プッシュ保護バイパス&lt;/a&gt;要求では、シークレットのファイル パスとブランチ情報が表示されるようになりました。この改善により、プッシュ保護のバイパスを要求したシークレットをより効果的に優先順位付けすることができます。ブランチ情報は、単一のブランチへのプッシュでのみ使用できます。&lt;/p&gt;
&lt;p&gt;シークレット スキャン プッシュ保護の委任バイパスにより、組織やリポジトリは、シークレットを含むコミットをプッシュできるユーザーを制御できます。開発者は、ブロックされたシークレットをプッシュするために、承認されたユーザーに承認を要求できます。&lt;/p&gt;
&lt;h4 id=&quot;learn-more&quot;&gt;もっと詳しく知る&lt;a href=&quot;#learn-more&quot; class=&quot;heading-link pl-2 text-italic text-bold&quot; aria-label=&quot;Learn more&quot;&gt;&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt; &lt;a href=&quot;https://docs.github.com/en/enterprise-cloud@latest/code-security/secret-scanning/about-secret-scanning&quot;&gt;シークレット スキャンを使用してリポジトリを保護する&lt;/a&gt;方法について詳しくは、こちらをご覧ください。 &lt;a href=&quot;https://github.com/orgs/community/discussions/categories/code-security&quot;&gt;GitHub コミュニティのディスカッション&lt;/a&gt;に参加するか、 &lt;a href=&quot;https://docs.google.com/forms/d/e/1FAIpQLSeQ8KzKQDvh7AD2vuTlqsPWkSo-IHh5XJUXdE6YmmLe8F98Kg/viewform?usp=sf_link&quot;&gt;60 分間のフィードバック セッション&lt;/a&gt;にサインアップして、ご意見をお聞かせください。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.blog/changelog/2024-08-26-secret-scanning-displays-branch-and-file-paths-for-push-protection-bypasses&quot;&gt;「シークレット スキャンでプッシュ保護バイパスのブランチとファイル パスが表示される」という&lt;/a&gt;投稿が最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に登場しました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79592</post-id></item><item><title>クライアント ID がアプリ API 応答に含まれるようになりました</title><link>https://github.blog/changelog/2024-08-23-client-ids-are-now-included-in-app-api-responses</link><dc:creator>Allison</dc:creator><pubDate>Fri, 23 Aug 2024 22:12:53 +0000</pubDate><guid isPermaLink="false">https://github.blog/changelog/2024-08-23-client-ids-are-now-included-in-app-api-responses</guid><description>&lt;p&gt;Client IDs are now included in App API responses&lt;/p&gt;
&lt;p&gt;The post &lt;a href=&quot;https://github.blog/changelog/2024-08-23-client-ids-are-now-included-in-app-api-responses&quot;&gt;Client IDs are now included in App API responses&lt;/a&gt; appeared first on &lt;a href=&quot;https://github.blog&quot;&gt;The GitHub Blog&lt;/a&gt;.&lt;/p&gt;
</description><content:encoded>&lt;p&gt;&lt;code&gt;client_id&lt;/code&gt;フィールドは、GitHub アプリを記述するすべての API 応答に含まれるようになりました。クライアント ID はグローバルに一意であるのに対し、アプリケーション ID と名前は一意ではないため、クライアント ID をアプリの主要な識別子として使用するように移行しています。&lt;/p&gt;
&lt;p&gt;歴史的に、GitHub は API でアプリケーションを識別するために&lt;code&gt;app_name&lt;/code&gt; (別名スラッグ) または&lt;code&gt;app_id&lt;/code&gt; (データベース ID) を使用してきました。ただし、アプリ名は不変ではなく、アプリ ID はグローバルに十分に一意ではありません。名前やデータベース ID ではなく、アプリケーションの&lt;code&gt;client_id&lt;/code&gt;をプライマリ識別子として使用できるように、すべてのアプリ関連 API を段階的に移行しています。これは、インストールに使用される&lt;a href=&quot;https://github.blog/changelog/2024-05-01-github-apps-can-now-use-the-client-id-to-fetch-installation-tokens/&quot;&gt;JWT を作成するためのクライアント ID の使用をサポートする&lt;/a&gt;変更で最初に見られました。トークン。&lt;/p&gt;
&lt;p&gt;この変更は、企業内のアプリケーションをプログラムで管理できる&lt;a href=&quot;https://github.com/github/roadmap/issues/963&quot;&gt;今後の機能&lt;/a&gt;に備えるために行われています。この追加データにより、関心のあるアプリケーションのクライアント ID を見つけやすくなります。&lt;/p&gt;
&lt;p&gt;アプリケーション情報を取得する方法の詳細については、 &lt;a href=&quot;https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#get-an-app&quot;&gt;REST API ドキュメント&lt;/a&gt;を参照してください。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.blog/changelog/2024-08-23-client-ids-are-now-included-in-app-api-responses&quot;&gt;「クライアント ID がアプリ API 応答に含まれるようになりました」&lt;/a&gt;という投稿は、最初に&lt;a href=&quot;https://github.blog&quot;&gt;GitHub ブログ&lt;/a&gt;に掲載されました。&lt;/p&gt;
</content:encoded><post-id xmlns="com-wordpress:feed-additions:1">79588</post-id></item></channel></rss>